<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>comment</key>
	<string></string>
	<key>fileTypes</key>
	<array>
		<string>clj</string>
	</array>
	<key>foldingStartMarker</key>
	<string>\(</string>
	<key>foldingStopMarker</key>
	<string>\)</string>
	<key>keyEquivalent</key>
	<string>^~L</string>
	<key>name</key>
	<string>Clojure</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#comment</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#shebang-comment</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#qouted-sexp</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#sexp</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#string</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#vector</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#set</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#map</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#regexp</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#constants</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#symbol</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>comment</key>
		<dict>
			<key>captures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.definition.comment.clojure</string>
				</dict>
			</dict>
			<key>match</key>
			<string>(;).*$\n?</string>
			<key>name</key>
			<string>comment.line.semicolon.clojure</string>
		</dict>
		<key>constants</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(nil)</string>
					<key>name</key>
					<string>constant.language.nil.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(true|false)</string>
					<key>name</key>
					<string>constant.language.boolean.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\d+/\d+)</string>
					<key>name</key>
					<string>constant.numeric.ratio.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\d+r\d+)</string>
					<key>name</key>
					<string>constant.numeric.arbitrary-radix.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(0x\d+)</string>
					<key>name</key>
					<string>constant.numeric.hexidecimal.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(0\d+)</string>
					<key>name</key>
					<string>constant.numeric.octal.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\b(=|\+|-|/|\*|if|var|accessor|aclone|add-classpath|add-watch|agent|agent-error|agent-errors|aget|alength|alias|all-ns|alter|alter-meta!|alter-var-root|amap|ancestors|and|apply|areduce|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|assoc!|assoc-in|associative\?|atom|await|await-for|bases|bean|bigdec|bigint|binding|bit-and|bit-and-not|bit-clear|bit-flip|bit-not|bit-or|bit-set|bit-shift-left|bit-shift-right|bit-test|bit-xor|boolean|boolean-array|booleans|bound-fn|bound-fn\*|bound\?|butlast|byte|byte-array|bytes|case|cast|char|char-array|char-escape-string|char-name-string|char\?|chars|class|class\?|clear-agent-errors|clojure-version|coll\?|comment|commute|comp|comparator|compare|compare-and-set!|compile|complement|concat|cond|condp|conj|conj!|cons|constantly|construct-proxy|contains\?|count|counted\?|create-ns|create-struct|cycle|dec|decimal\?|declare|definline|defmacro|defmethod|defmulti|defn|defn-|defonce|defprotocol|defrecord|defstruct|deftype|delay|delay\?|deliver|denominator|deref|derive|descendants|disj|disj!|dissoc|dissoc!|distinct|distinct\?|doall|doc|dorun|doseq|dosync|dotimes|doto|double|double-array|doubles|drop|drop-last|drop-while|empty|empty\?|ensure|enumeration-seq|error-handler|error-mode|eval|even\?|every\?|extend|extend-protocol|extend-type|extenders|extends\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|flatten|float|float-array|float\?|floats|flush|fn|fn\?|fnext|fnil|for|force|format|frequencies|future|future-call|future-cancel|future-cancelled\?|future-done\?|future\?|gen-class|gen-interface|gensym|get|get-in|get-method|get-proxy-class|get-thread-bindings|get-validator|group-by|hash|hash-map|hash-set|identical\?|identity|if-let|if-not|ifn\?|import|in-ns|inc|init-proxy|instance\?|int|int-array|integer\?|interleave|intern|interpose|into|into-array|ints|io!|isa\?|iterate|iterator-seq|juxt|keep|keep-indexed|key|keys|keyword|keyword\?|last|lazy-cat|lazy-seq|let|letfn|line-seq|list|list\*|list\?|load|load-file|load-reader|load-string|loaded-libs|locking|long|long-array|longs|loop|macroexpand|macroexpand-1|make-array|make-hierarchy|map|map-indexed|map\?|mapcat|max|max-key|memfn|memoize|merge|merge-with|meta|methods|min|min-key|mod|name|namespace|namespace-munge|neg\?|newline|next|nfirst|nil\?|nnext|not|not-any\?|not-empty|not-every\?|not=|ns|ns-aliases|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unalias|ns-unmap|nth|nthnext|num|number\?|numerator|object-array|odd\?|or|parents|partial|partition|partition-all|partition-by|pcalls|peek|persistent!|pmap|pop|pop!|pop-thread-bindings|pos\?|pr|pr-str|prefer-method|prefers|print|print-namespace-doc|print-str|printf|println|println-str|prn|prn-str|promise|proxy|proxy-mappings|proxy-super|push-thread-bindings|pvalues|quot|rand|rand-int|rand-nth|range|ratio\?|rationalize|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|read-string|reduce|reductions|ref|ref-history-count|ref-max-history|ref-min-history|ref-set|refer|refer-clojure|reify|release-pending-sends|rem|remove|remove-all-methods|remove-method|remove-ns|remove-watch|repeat|repeatedly|replace|replicate|require|reset!|reset-meta!|resolve|rest|restart-agent|resultset-seq|reverse|reversible\?|rseq|rsubseq|satisfies\?|second|select-keys|send|send-off|seq|seq\?|seque|sequence|sequential\?|set|set-error-handler!|set-error-mode!|set-validator!|set\?|short|short-array|shorts|shuffle|shutdown-agents|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|sorted-set-by|sorted\?|special-form-anchor|special-symbol\?|spit|split-at|split-with|str|string\?|struct|struct-map|subs|subseq|subvec|supers|swap!|symbol|symbol\?|sync|syntax-symbol-anchor|take|take-last|take-nth|take-while|test|the-ns|thread-bound\?|time|to-array|to-array-2d|trampoline|transient|tree-seq|true\?|type|unchecked-add|unchecked-dec|unchecked-divide|unchecked-inc|unchecked-multiply|unchecked-negate|unchecked-remainder|unchecked-subtract|underive|update-in|update-proxy|use|val|vals|var-get|var-set|var\?|vary-meta|vec|vector|vector-of|vector\?|when|when-first|when-let|when-not|while|with-bindings|with-bindings\*|with-in-str|with-local-vars|with-meta|with-open|with-out-str|with-precision|xml-seq|zero\?|zipmap)\b</string>
					<key>name</key>
					<string>keyword.control.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\d+)</string>
					<key>name</key>
					<string>constant.numeric.decimal.clojure</string>
				</dict>
			</array>
		</dict>
		<key>map</key>
		<dict>
			<key>begin</key>
			<string>(\{)</string>
			<key>end</key>
			<string>(\})</string>
			<key>name</key>
			<string>meta.map.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>$self</string>
				</dict>
			</array>
		</dict>
		<key>qouted-sexp</key>
		<dict>
			<key>begin</key>
			<string>(['``]\()</string>
			<key>beginCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.section.expression.begin.clojure</string>
				</dict>
			</dict>
			<key>end</key>
			<string>(\))(\n)?</string>
			<key>endCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.section.expression.end.clojure</string>
				</dict>
				<key>2</key>
				<dict>
					<key>name</key>
					<string>meta.after-expression.clojure</string>
				</dict>
			</dict>
			<key>name</key>
			<string>meta.qouted-expression.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>$self</string>
				</dict>
			</array>
		</dict>
		<key>regexp</key>
		<dict>
			<key>begin</key>
			<string>#\"</string>
			<key>end</key>
			<string>\"</string>
			<key>name</key>
			<string>string.regexp.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#regexp_escaped_char</string>
				</dict>
			</array>
		</dict>
		<key>regexp_escaped_char</key>
		<dict>
			<key>match</key>
			<string>\\(\")</string>
			<key>name</key>
			<string>string.regexp.clojure</string>
		</dict>
		<key>set</key>
		<dict>
			<key>begin</key>
			<string>(\#\{)</string>
			<key>end</key>
			<string>(\})</string>
			<key>name</key>
			<string>meta.set.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>$self</string>
				</dict>
			</array>
		</dict>
		<key>sexp</key>
		<dict>
			<key>begin</key>
			<string>(\()</string>
			<key>beginCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.section.expression.begin.clojure</string>
				</dict>
			</dict>
			<key>end</key>
			<string>(\))(\n)?</string>
			<key>endCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.section.expression.end.clojure</string>
				</dict>
				<key>2</key>
				<dict>
					<key>name</key>
					<string>meta.after-expression.clojure</string>
				</dict>
			</dict>
			<key>name</key>
			<string>meta.expression.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\()(def|def-|deftest)\s+(.+?)(?=\s)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.clojure</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.global.clojure</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?=\))</string>
					<key>name</key>
					<string>meta.definition.global.clojure</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\()(defn|defn-|deftest)\s+(.+?)(?=\s)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.clojure</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.function.clojure</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?=\))</string>
					<key>name</key>
					<string>meta.definition.function.clojure</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\()(defmacro|defmacro-)\s+(.+?)(?=\s)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.clojure</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.macro.clojure</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?=\))</string>
					<key>name</key>
					<string>meta.definition.macro.clojure</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>$self</string>
				</dict>
			</array>
		</dict>
		<key>shebang-comment</key>
		<dict>
			<key>captures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.definition.comment.shebang.clojure</string>
				</dict>
			</dict>
			<key>match</key>
			<string>^(\#!).*$\n?</string>
			<key>name</key>
			<string>comment.line.semicolon.clojure</string>
		</dict>
		<key>string</key>
		<dict>
			<key>begin</key>
			<string>(")</string>
			<key>beginCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.definition.string.begin.clojure</string>
				</dict>
			</dict>
			<key>end</key>
			<string>(")</string>
			<key>endCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>punctuation.definition.string.end.clojure</string>
				</dict>
			</dict>
			<key>name</key>
			<string>string.quoted.double.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\\.</string>
					<key>name</key>
					<string>constant.character.escape.clojure</string>
				</dict>
			</array>
		</dict>
		<key>symbol</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(\w[\w\d]+)</string>
					<key>name</key>
					<string>meta.symbol.clojure</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(:\w[\w\d]+)</string>
					<key>name</key>
					<string>constant.other.symbol.clojure</string>
				</dict>
			</array>
		</dict>
		<key>vector</key>
		<dict>
			<key>begin</key>
			<string>(\[)</string>
			<key>end</key>
			<string>(\])</string>
			<key>name</key>
			<string>meta.vector.clojure</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>$self</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.clojure</string>
	<key>uuid</key>
	<string>6A87759F-F746-4E84-B788-965B46363202</string>
</dict>
</plist>
